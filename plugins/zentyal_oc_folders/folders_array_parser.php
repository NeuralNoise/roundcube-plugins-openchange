<?php
    define("MAIL_CONTAINER", "IPF.Note");
    define("DELIMITER", "/");

    /**
     * Parses a given phpbinding's folder array in a recursive way
     *
     * Given a folder array generated by the PHPbindings (it can be
     * deeper shown at folders_array_mock.php class) it returns an
     * array that Roundcube "storage_folders" hook understands.
     *
     * Starting from the root node, this class mainly looks for any mail
     * container, and then, looks for any other subfolder inside it. It
     * is done in a recursive way.
     *
     * This is an example of how Roundcube needs the array to be populated:
     *
     * Array
     * (
     *     [0] => Sync Issues
     *     [1] => Sync Issues/Conflicts
     *     [2] => Sync Issues/Local Failures
     *     [3] => Sync Issues/Server Failures
     *     [4] => Sync Issues/Server Failures/Third level
     *     [5] => Sync Issues/Server Failures/Third level/Forth level
     * )
     *
     * If there is no "Inbox" element in the array, Roundcube will add it by
     * its own.
     *
     * @author  Miguel Julian <mjulian@zentyal.com>
     */
    class folders_array_parser {
        /**
         * Main function which it'd be invoked from outside
         */
        function parse_array($root){
            if ($this->array_is_correct($root)) {
                $folders_names = $this->parse_folders($root);
            }

            return $folders_names;
        }


        /**
         * Recursive function that looks for mail nodes in a given level
         */
        private function parse_folders($root, $prefix=""){
            $parsed_folders = array();

            $folders = $root['childs'];

            foreach($folders as $folder){
                $name = $this->parse_name($folder, $prefix);
                if ($name){
                    $parsed_folders = array_merge($parsed_folders, (array)$name);
                }

                if ($this->has_subfolders($folder)){
                    $parsed_folders = array_merge(
                        $parsed_folders,
                        $this->parse_folders($folder, $this->get_full_name($folder['name'], $prefix))
                    );
                }
            }

            return $parsed_folders;
        }


        /**
         * Returns the proper name for a given folder.
         */
        private function parse_name($folder, $prefix=''){
            if ($this->is_mail_container($folder) && $folder['name']) {
                return $this->get_full_name($folder['name'], $prefix);
            }

            return "";
        }

        private function get_full_name($name, $prefix){
            if ($prefix){
                return ($prefix . DELIMITER .  $name);
            }else{
                return $name;
            }
        }


        private function array_is_correct($root){
            return is_array($root) && is_array($root['childs']) && sizeof($root['childs']);
        }


        private function is_mail_container($folder){
            return $folder['container'] == MAIL_CONTAINER;
        }


        private function has_subfolders($folder){
            return is_array($folder['childs']) && sizeOf($folder['childs']);
        }

    }
?>
